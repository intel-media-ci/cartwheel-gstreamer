From cb42ba8b09b47c7823d77f347b32914e2ff57cea Mon Sep 17 00:00:00 2001
From: Haihao Xiang <haihao.xiang@intel.com>
Date: Thu, 8 Apr 2021 13:29:20 +0800
Subject: [PATCH 1/6] msdk: add msdkav1enc element

msdkav1enc is available when -Dmfx_api=oneVPL
---
 .../gst-plugins-bad/sys/msdk/gstmsdk.c        |   9 +
 .../gst-plugins-bad/sys/msdk/meson.build      |   5 +
 sys/msdk/av1_temp.h                           | 120 +++++++++
 sys/msdk/gstmsdkav1enc.c                      | 249 ++++++++++++++++++
 sys/msdk/gstmsdkav1enc.h                      |  73 +++++
 5 files changed, 456 insertions(+)
 create mode 100644 sys/msdk/av1_temp.h
 create mode 100644 sys/msdk/gstmsdkav1enc.c
 create mode 100644 sys/msdk/gstmsdkav1enc.h

diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdk.c b/subprojects/gst-plugins-bad/sys/msdk/gstmsdk.c
index 0773cf56c0..f7d3b5ebea 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdk.c
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdk.c
@@ -62,6 +62,9 @@
 #ifdef USE_MSDK_AV1_DEC
 #include "gstmsdkav1dec.h"
 #endif
+#ifdef USE_MSDK_AV1_ENC
+#include "gstmsdkav1enc.h"
+#endif
 #include "gstmsdkvpp.h"
 
 GST_DEBUG_CATEGORY (gst_msdk_debug);
@@ -81,6 +84,7 @@ GST_DEBUG_CATEGORY (gst_msdkvc1dec_debug);
 GST_DEBUG_CATEGORY (gst_msdkvp9dec_debug);
 GST_DEBUG_CATEGORY (gst_msdkvp9enc_debug);
 GST_DEBUG_CATEGORY (gst_msdkav1dec_debug);
+GST_DEBUG_CATEGORY (gst_msdkav1enc_debug);
 
 static void
 plugin_add_dependencies (GstPlugin * plugin)
@@ -137,6 +141,7 @@ plugin_init (GstPlugin * plugin)
   GST_DEBUG_CATEGORY_INIT (gst_msdkvp9dec_debug, "msdkvp9dec", 0, "msdkvp9dec");
   GST_DEBUG_CATEGORY_INIT (gst_msdkvp9enc_debug, "msdkvp9enc", 0, "msdkvp9enc");
   GST_DEBUG_CATEGORY_INIT (gst_msdkav1dec_debug, "msdkav1dec", 0, "msdkav1dec");
+  GST_DEBUG_CATEGORY_INIT (gst_msdkav1dec_debug, "msdkav1enc", 0, "msdkav1enc");
 
   plugin_add_dependencies (plugin);
 
@@ -183,6 +188,10 @@ plugin_init (GstPlugin * plugin)
 #ifdef USE_MSDK_AV1_DEC
   ret = gst_element_register (plugin, "msdkav1dec", GST_RANK_NONE,
       GST_TYPE_MSDKAV1DEC);
+#endif
+#ifdef USE_MSDK_AV1_ENC
+  ret = gst_element_register (plugin, "msdkav1enc", GST_RANK_NONE,
+      GST_TYPE_MSDKAV1ENC);
 #endif
   ret = gst_element_register (plugin, "msdkvpp", GST_RANK_NONE,
       GST_TYPE_MSDKVPP);
diff --git a/subprojects/gst-plugins-bad/sys/msdk/meson.build b/subprojects/gst-plugins-bad/sys/msdk/meson.build
index c06d63e680..ffd5f87bf2 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/meson.build
+++ b/subprojects/gst-plugins-bad/sys/msdk/meson.build
@@ -138,6 +138,11 @@ if have_mfx_ver134
   cdata.set10('USE_MSDK_AV1_DEC', 1)
 endif
 
+if use_onevpl
+  msdk_sources += [ 'gstmsdkav1enc.c' ]
+  cdata.set10('USE_MSDK_AV1_ENC', 1)
+endif
+
 if host_machine.system() == 'windows'
   if cc.get_id() != 'msvc' and msdk_option.enabled()
     error('msdk plugin can only be built with MSVC')
diff --git a/sys/msdk/av1_temp.h b/sys/msdk/av1_temp.h
new file mode 100644
index 0000000000..2f3d99fe38
--- /dev/null
+++ b/sys/msdk/av1_temp.h
@@ -0,0 +1,120 @@
+/*############################################################################
+  # Copyright (C) 2018-2021 Intel Corporation
+  #
+  # SPDX-License-Identifier: MIT
+  ############################################################################*/
+
+#ifndef __AV1_TEMP_H__
+#define __AV1_TEMP_H__
+#include <mfxcommon.h>
+
+#if !defined (__GNUC__)
+#pragma warning(disable: 4201)
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef MFX_VERSION_NEXT
+
+enum {
+    MFX_EXTBUFF_AV1_PARAM                       = MFX_MAKEFOURCC('1', 'P', 'A', 'R'),
+    MFX_EXTBUFF_AV1_AUXDATA                     = MFX_MAKEFOURCC('1', 'A', 'U', 'X')
+};
+
+MFX_PACK_BEGIN_USUAL_STRUCT()
+typedef struct {
+    mfxExtBuffer Header;
+
+    mfxU16  FrameWidth;
+    mfxU16  FrameHeight;
+
+    mfxU8   WriteIVFHeaders;          /* tri-state option */
+    mfxU8   UseAnnexB;                /* tri-state option */
+    mfxU8   PackOBUFrame;             /* tri-state option */
+    mfxU8   InsertTemporalDelimiter;  /* tri-state option */
+
+    mfxU8   UniformTileSpacing;       /* tri-state option */
+    mfxU8   ContextUpdateTileIdPlus1; /* Minus 1 specifies context_update_tile_id */
+    mfxU16  NumTileRows;
+    mfxU16  NumTileColumns;
+    mfxU16  NumTileGroups;
+    mfxU16  NumTilesPerTileGroup[256];
+    mfxU16  TileWidthInSB[128];
+    mfxU16  TileHeightInSB[128];
+
+    mfxU8   EnableCdef;               /* tri-state option */
+    mfxU8   EnableRestoration;        /* tri-state option */
+    mfxU8   LoopFilterSharpness;      /* 0..8, 0 = default, map to bitstream: [1..8] => [0..7] */
+
+    mfxU8   InterpFilter;             /* see enum AV1InterpolationMode */
+
+    mfxU8   SegmentationMode;         /* see enum AV1SegmentMode*/
+
+    mfxU8   DisableCdfUpdate;         /* tri-state option */
+    mfxU8   DisableFrameEndUpdateCdf; /* tri-state option */
+
+    mfxU8   EnableSuperres;           /* tri-state option */
+    mfxU8   SuperresScaleDenominator; /* 9..16, 0 = default */
+
+    mfxU8   StillPictureMode;         /* tri-state option */
+    mfxU16  SwitchInterval;           /* interval, 0 - disabled */
+
+    mfxU8   EnableLoopFilter;         /* tri-state option */
+
+    mfxU8   reserved[63];
+} mfxExtAV1Param;
+MFX_PACK_END()
+
+MFX_PACK_BEGIN_USUAL_STRUCT()
+typedef struct {
+    mfxExtBuffer Header;
+
+    struct {
+        mfxU8  CdefDampingMinus3;   /* 0..3 */
+        mfxU8  CdefBits;            /* 0..3 */
+        mfxU8  CdefYStrengths[8];   /* 0..63 */
+        mfxU8  CdefUVStrengths[8];  /* 0..63 */
+        mfxU8  reserved[14];
+    } Cdef;
+
+    struct {
+        mfxU8  LFLevelYVert;        /* 0..63 */
+        mfxU8  LFLevelYHorz;        /* 0..63 */
+        mfxU8  LFLevelU;            /* 0..63 */
+        mfxU8  LFLevelV;            /* 0..63 */
+        mfxU8  ModeRefDeltaEnabled; /* 0, 1 */
+        mfxU8  ModeRefDeltaUpdate;  /* 0, 1 */
+        mfxI8  RefDeltas[8];        /* -63..63 */
+        mfxI8  ModeDeltas[2];       /* -63..63 */
+        mfxU8  reserved[16];
+    } LoopFilter;
+
+    struct {
+        mfxI8  YDcDeltaQ;           /* -63..63 */
+        mfxI8  UDcDeltaQ;           /* -63..63 */
+        mfxI8  VDcDeltaQ;           /* -63..63 */
+        mfxI8  UAcDeltaQ;           /* -63..63 */
+        mfxI8  VAcDeltaQ;           /* -63..63 */
+        mfxU8  MinBaseQIndex;
+        mfxU8  MaxBaseQIndex;
+        mfxU8  reserved[25];
+    } QP;
+
+    mfxU8  ErrorResilientMode;          /* tri-state option */
+    mfxU8  EnableOrderHint;             /* tri-state option */
+    mfxU8  OrderHintBits;               /* 0..8, 0 = default */
+    mfxU8  DisplayFormatSwizzle;        /* 0, 1 */
+
+    mfxU8  reserved[60];
+} mfxExtAV1AuxData;
+MFX_PACK_END()
+
+#endif
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/sys/msdk/gstmsdkav1enc.c b/sys/msdk/gstmsdkav1enc.c
new file mode 100644
index 0000000000..0d82914c7e
--- /dev/null
+++ b/sys/msdk/gstmsdkav1enc.c
@@ -0,0 +1,249 @@
+/*
+ * GStreamer Intel MSDK plugin
+ * Copyright (c) 2021 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <gst/allocators/gstdmabuf.h>
+
+#include "gstmsdkav1enc.h"
+
+GST_DEBUG_CATEGORY_EXTERN (gst_msdkav1enc_debug);
+#define GST_CAT_DEFAULT gst_msdkav1enc_debug
+
+#define RAW_FORMATS "NV12, I420, YV12"
+#define PROFILES    "main"
+
+#define COMMON_FORMAT "{ " RAW_FORMATS " }"
+#define SRC_PROFILES  "{ " PROFILES " }"
+
+static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_MSDK_CAPS_STR (COMMON_FORMAT,
+            "{ NV12 }")));
+
+static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-av1, "
+        "framerate = (fraction) [0/1, MAX], "
+        "width = (int) [ 1, MAX ], height = (int) [ 1, MAX ], "
+        "profile = (string) " SRC_PROFILES)
+    );
+
+#define gst_msdkav1enc_parent_class parent_class
+G_DEFINE_TYPE (GstMsdkAV1Enc, gst_msdkav1enc, GST_TYPE_MSDKENC);
+
+static gboolean
+gst_msdkav1enc_set_format (GstMsdkEnc * encoder)
+{
+  GstMsdkAV1Enc *thiz = GST_MSDKAV1ENC (encoder);
+  GstCaps *template_caps;
+  GstCaps *allowed_caps = NULL;
+
+  thiz->profile = MFX_PROFILE_AV1_MAIN;
+  template_caps = gst_static_pad_template_get_caps (&src_factory);
+  allowed_caps = gst_pad_get_allowed_caps (GST_VIDEO_ENCODER_SRC_PAD (encoder));
+
+  /* If downstream has ANY caps let encoder decide profile and level */
+  if (allowed_caps == template_caps) {
+    GST_INFO_OBJECT (thiz,
+        "downstream has ANY caps, profile/level set to auto");
+  } else if (allowed_caps) {
+    GstStructure *s;
+    const gchar *profile;
+
+    if (gst_caps_is_empty (allowed_caps)) {
+      gst_caps_unref (allowed_caps);
+      gst_caps_unref (template_caps);
+      return FALSE;
+    }
+
+    allowed_caps = gst_caps_make_writable (allowed_caps);
+    allowed_caps = gst_caps_fixate (allowed_caps);
+    s = gst_caps_get_structure (allowed_caps, 0);
+    profile = gst_structure_get_string (s, "profile");
+
+    if (profile) {
+      if (!strcmp (profile, "main")) {
+        thiz->profile = MFX_PROFILE_AV1_MAIN;
+      } else {
+        g_assert_not_reached ();
+      }
+    }
+
+    gst_caps_unref (allowed_caps);
+  }
+
+  gst_caps_unref (template_caps);
+
+  return TRUE;
+}
+
+static gboolean
+gst_msdkav1enc_configure (GstMsdkEnc * encoder)
+{
+  GstMsdkAV1Enc *av1enc = GST_MSDKAV1ENC (encoder);
+
+  encoder->num_extra_frames = encoder->async_depth - 1;
+  encoder->param.mfx.CodecId = MFX_CODEC_AV1;
+  encoder->param.mfx.CodecLevel = 0;
+
+  switch (encoder->param.mfx.FrameInfo.FourCC) {
+    case MFX_FOURCC_NV12:
+      encoder->param.mfx.CodecProfile = MFX_PROFILE_AV1_MAIN;
+      break;
+
+    default:
+      g_assert_not_reached ();
+      break;
+  }
+
+  encoder->param.mfx.FrameInfo.Width =
+      GST_ROUND_UP_128 (encoder->param.mfx.FrameInfo.CropW);
+  encoder->param.mfx.FrameInfo.Height =
+      GST_ROUND_UP_32 (encoder->param.mfx.FrameInfo.CropH);
+
+  /* Always turn on this flag for AV1 */
+  /* encoder->param.mfx.LowPower = MFX_CODINGOPTION_ON; */
+
+  /* Enable Extended coding options */
+  encoder->option3.GPB = MFX_CODINGOPTION_OFF;
+  encoder->enable_extopt3 = TRUE;
+  gst_msdkenc_ensure_extended_coding_options (encoder);
+
+  memset (&av1enc->ext_av1, 0, sizeof (av1enc->ext_av1));
+  av1enc->ext_av1.Header.BufferId = MFX_EXTBUFF_AV1_PARAM;
+  av1enc->ext_av1.Header.BufferSz = sizeof (av1enc->ext_av1);
+  av1enc->ext_av1.FrameWidth = encoder->param.mfx.FrameInfo.CropW;
+  av1enc->ext_av1.FrameHeight = encoder->param.mfx.FrameInfo.CropH;
+  av1enc->ext_av1.PackOBUFrame = MFX_CODINGOPTION_OFF;
+  av1enc->ext_av1.DisableFrameEndUpdateCdf = MFX_CODINGOPTION_OFF;
+  av1enc->ext_av1.EnableCdef = MFX_CODINGOPTION_OFF;
+  gst_msdkenc_add_extra_param (encoder, (mfxExtBuffer *) & av1enc->ext_av1);
+
+  memset (&av1enc->ext_av1_auxdata, 0, sizeof (av1enc->ext_av1_auxdata));
+  av1enc->ext_av1_auxdata.Header.BufferId = MFX_EXTBUFF_AV1_AUXDATA;
+  av1enc->ext_av1_auxdata.Header.BufferSz = sizeof (av1enc->ext_av1_auxdata);
+  av1enc->ext_av1_auxdata.EnableOrderHint = MFX_CODINGOPTION_ON;
+  av1enc->ext_av1_auxdata.OrderHintBits = 8;
+  gst_msdkenc_add_extra_param (encoder,
+      (mfxExtBuffer *) & av1enc->ext_av1_auxdata);
+
+  return TRUE;
+}
+
+static inline const gchar *
+profile_to_string (gint profile)
+{
+  switch (profile) {
+    case MFX_PROFILE_AV1_MAIN:
+      return "main";
+    default:
+      break;
+  }
+
+  return NULL;
+}
+
+static GstCaps *
+gst_msdkav1enc_set_src_caps (GstMsdkEnc * encoder)
+{
+  GstCaps *caps;
+  GstStructure *structure;
+  const gchar *profile;
+
+  caps = gst_caps_new_empty_simple ("video/x-av1");
+  structure = gst_caps_get_structure (caps, 0);
+
+  profile = profile_to_string (encoder->param.mfx.CodecProfile);
+  if (profile)
+    gst_structure_set (structure, "profile", G_TYPE_STRING, profile, NULL);
+
+  return caps;
+}
+
+static void
+gst_msdkav1enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstMsdkAV1Enc *thiz = GST_MSDKAV1ENC (object);
+
+  if (!gst_msdkenc_set_common_property (object, prop_id, value, pspec))
+    GST_WARNING_OBJECT (thiz, "Failed to set common encode property");
+}
+
+static void
+gst_msdkav1enc_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  GstMsdkAV1Enc *thiz = GST_MSDKAV1ENC (object);
+
+  if (!gst_msdkenc_get_common_property (object, prop_id, value, pspec))
+    GST_WARNING_OBJECT (thiz, "Failed to get common encode property");
+}
+
+static void
+gst_msdkav1enc_class_init (GstMsdkAV1EncClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+  GstMsdkEncClass *encoder_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+  encoder_class = GST_MSDKENC_CLASS (klass);
+
+  gobject_class->set_property = gst_msdkav1enc_set_property;
+  gobject_class->get_property = gst_msdkav1enc_get_property;
+
+  encoder_class->set_format = gst_msdkav1enc_set_format;
+  encoder_class->configure = gst_msdkav1enc_configure;
+  encoder_class->set_src_caps = gst_msdkav1enc_set_src_caps;
+
+  gst_msdkenc_install_common_properties (encoder_class);
+
+  gst_element_class_set_static_metadata (element_class,
+      "Intel MSDK AV1 encoder",
+      "Codec/Encoder/Video/Hardware",
+      "AV1 video encoder based on Intel Media SDK",
+      "Haihao Xiang <haihao.xiang@intel.com>");
+
+  gst_element_class_add_static_pad_template (element_class, &sink_factory);
+  gst_element_class_add_static_pad_template (element_class, &src_factory);
+}
+
+static void
+gst_msdkav1enc_init (GstMsdkAV1Enc * thiz)
+{
+}
diff --git a/sys/msdk/gstmsdkav1enc.h b/sys/msdk/gstmsdkav1enc.h
new file mode 100644
index 0000000000..6ca7d63d44
--- /dev/null
+++ b/sys/msdk/gstmsdkav1enc.h
@@ -0,0 +1,73 @@
+/*
+ * GStreamer Intel MSDK plugin
+ * Copyright (c) 2021 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __GST_MSDKAV1ENC_H__
+#define __GST_MSDKAV1ENC_H__
+
+#include "gstmsdkenc.h"
+#include "av1_temp.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_MSDKAV1ENC \
+  (gst_msdkav1enc_get_type())
+#define GST_MSDKAV1ENC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKAV1ENC,GstMsdkAV1Enc))
+#define GST_MSDKAV1ENC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKAV1ENC,GstMsdkAV1EncClass))
+#define GST_IS_MSDKAV1ENC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKAV1ENC))
+#define GST_IS_MSDKAV1ENC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKAV1ENC))
+
+typedef struct _GstMsdkAV1Enc GstMsdkAV1Enc;
+typedef struct _GstMsdkAV1EncClass GstMsdkAV1EncClass;
+
+struct _GstMsdkAV1Enc
+{
+  GstMsdkEnc base;
+
+  gint profile;
+
+  mfxExtAV1Param ext_av1;
+  mfxExtAV1AuxData ext_av1_auxdata;
+};
+
+struct _GstMsdkAV1EncClass
+{
+  GstMsdkEncClass parent_class;
+};
+
+GType gst_msdkav1enc_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_MSDKAV1ENC_H__ */
-- 
2.17.1

